// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/openshift/zero-trust-workload-identity-manager/pkg/client"
	clienta "sigs.k8s.io/controller-runtime/pkg/client"
)

type FakeCustomCtrlClient struct {
	CreateStub        func(context.Context, clienta.Object, ...clienta.CreateOption) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.CreateOption
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	CreateOrUpdateObjectStub        func(context.Context, clienta.Object) error
	createOrUpdateObjectMutex       sync.RWMutex
	createOrUpdateObjectArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
	}
	createOrUpdateObjectReturns struct {
		result1 error
	}
	createOrUpdateObjectReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(context.Context, clienta.Object, ...clienta.DeleteOption) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.DeleteOption
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	ExistsStub        func(context.Context, clienta.ObjectKey, clienta.Object) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.ObjectKey
		arg3 clienta.Object
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetStub        func(context.Context, clienta.ObjectKey, clienta.Object) error
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.ObjectKey
		arg3 clienta.Object
	}
	getReturns struct {
		result1 error
	}
	getReturnsOnCall map[int]struct {
		result1 error
	}
	ListStub        func(context.Context, clienta.ObjectList, ...clienta.ListOption) error
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.ObjectList
		arg3 []clienta.ListOption
	}
	listReturns struct {
		result1 error
	}
	listReturnsOnCall map[int]struct {
		result1 error
	}
	PatchStub        func(context.Context, clienta.Object, clienta.Patch, ...clienta.PatchOption) error
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 clienta.Patch
		arg4 []clienta.PatchOption
	}
	patchReturns struct {
		result1 error
	}
	patchReturnsOnCall map[int]struct {
		result1 error
	}
	StatusUpdateStub        func(context.Context, clienta.Object, ...clienta.SubResourceUpdateOption) error
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.SubResourceUpdateOption
	}
	statusUpdateReturns struct {
		result1 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	StatusUpdateWithRetryStub        func(context.Context, clienta.Object, ...clienta.SubResourceUpdateOption) error
	statusUpdateWithRetryMutex       sync.RWMutex
	statusUpdateWithRetryArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.SubResourceUpdateOption
	}
	statusUpdateWithRetryReturns struct {
		result1 error
	}
	statusUpdateWithRetryReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(context.Context, clienta.Object, ...clienta.UpdateOption) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.UpdateOption
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateWithRetryStub        func(context.Context, clienta.Object, ...clienta.UpdateOption) error
	updateWithRetryMutex       sync.RWMutex
	updateWithRetryArgsForCall []struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.UpdateOption
	}
	updateWithRetryReturns struct {
		result1 error
	}
	updateWithRetryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCustomCtrlClient) Create(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.CreateOption) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.CreateOption
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeCustomCtrlClient) CreateCalls(stub func(context.Context, clienta.Object, ...clienta.CreateOption) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeCustomCtrlClient) CreateArgsForCall(i int) (context.Context, clienta.Object, []clienta.CreateOption) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObject(arg1 context.Context, arg2 clienta.Object) error {
	fake.createOrUpdateObjectMutex.Lock()
	ret, specificReturn := fake.createOrUpdateObjectReturnsOnCall[len(fake.createOrUpdateObjectArgsForCall)]
	fake.createOrUpdateObjectArgsForCall = append(fake.createOrUpdateObjectArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
	}{arg1, arg2})
	stub := fake.CreateOrUpdateObjectStub
	fakeReturns := fake.createOrUpdateObjectReturns
	fake.recordInvocation("CreateOrUpdateObject", []interface{}{arg1, arg2})
	fake.createOrUpdateObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObjectCallCount() int {
	fake.createOrUpdateObjectMutex.RLock()
	defer fake.createOrUpdateObjectMutex.RUnlock()
	return len(fake.createOrUpdateObjectArgsForCall)
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObjectCalls(stub func(context.Context, clienta.Object) error) {
	fake.createOrUpdateObjectMutex.Lock()
	defer fake.createOrUpdateObjectMutex.Unlock()
	fake.CreateOrUpdateObjectStub = stub
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObjectArgsForCall(i int) (context.Context, clienta.Object) {
	fake.createOrUpdateObjectMutex.RLock()
	defer fake.createOrUpdateObjectMutex.RUnlock()
	argsForCall := fake.createOrUpdateObjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObjectReturns(result1 error) {
	fake.createOrUpdateObjectMutex.Lock()
	defer fake.createOrUpdateObjectMutex.Unlock()
	fake.CreateOrUpdateObjectStub = nil
	fake.createOrUpdateObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) CreateOrUpdateObjectReturnsOnCall(i int, result1 error) {
	fake.createOrUpdateObjectMutex.Lock()
	defer fake.createOrUpdateObjectMutex.Unlock()
	fake.CreateOrUpdateObjectStub = nil
	if fake.createOrUpdateObjectReturnsOnCall == nil {
		fake.createOrUpdateObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createOrUpdateObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) Delete(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.DeleteOption) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.DeleteOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeCustomCtrlClient) DeleteCalls(stub func(context.Context, clienta.Object, ...clienta.DeleteOption) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeCustomCtrlClient) DeleteArgsForCall(i int) (context.Context, clienta.Object, []clienta.DeleteOption) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) Exists(arg1 context.Context, arg2 clienta.ObjectKey, arg3 clienta.Object) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.ObjectKey
		arg3 clienta.Object
	}{arg1, arg2, arg3})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1, arg2, arg3})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomCtrlClient) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeCustomCtrlClient) ExistsCalls(stub func(context.Context, clienta.ObjectKey, clienta.Object) (bool, error)) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakeCustomCtrlClient) ExistsArgsForCall(i int) (context.Context, clienta.ObjectKey, clienta.Object) {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) ExistsReturns(result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomCtrlClient) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomCtrlClient) Get(arg1 context.Context, arg2 clienta.ObjectKey, arg3 clienta.Object) error {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.ObjectKey
		arg3 clienta.Object
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeCustomCtrlClient) GetCalls(stub func(context.Context, clienta.ObjectKey, clienta.Object) error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeCustomCtrlClient) GetArgsForCall(i int) (context.Context, clienta.ObjectKey, clienta.Object) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) GetReturns(result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) GetReturnsOnCall(i int, result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) List(arg1 context.Context, arg2 clienta.ObjectList, arg3 ...clienta.ListOption) error {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.ObjectList
		arg3 []clienta.ListOption
	}{arg1, arg2, arg3})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1, arg2, arg3})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeCustomCtrlClient) ListCalls(stub func(context.Context, clienta.ObjectList, ...clienta.ListOption) error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeCustomCtrlClient) ListArgsForCall(i int) (context.Context, clienta.ObjectList, []clienta.ListOption) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) ListReturns(result1 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) ListReturnsOnCall(i int, result1 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) Patch(arg1 context.Context, arg2 clienta.Object, arg3 clienta.Patch, arg4 ...clienta.PatchOption) error {
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 clienta.Patch
		arg4 []clienta.PatchOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.PatchStub
	fakeReturns := fake.patchReturns
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3, arg4})
	fake.patchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeCustomCtrlClient) PatchCalls(stub func(context.Context, clienta.Object, clienta.Patch, ...clienta.PatchOption) error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *FakeCustomCtrlClient) PatchArgsForCall(i int) (context.Context, clienta.Object, clienta.Patch, []clienta.PatchOption) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCustomCtrlClient) PatchReturns(result1 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) PatchReturnsOnCall(i int, result1 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) StatusUpdate(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.SubResourceUpdateOption) error {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.SubResourceUpdateOption
	}{arg1, arg2, arg3})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1, arg2, arg3})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakeCustomCtrlClient) StatusUpdateCalls(stub func(context.Context, clienta.Object, ...clienta.SubResourceUpdateOption) error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakeCustomCtrlClient) StatusUpdateArgsForCall(i int) (context.Context, clienta.Object, []clienta.SubResourceUpdateOption) {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) StatusUpdateReturns(result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) StatusUpdateReturnsOnCall(i int, result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetry(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.SubResourceUpdateOption) error {
	fake.statusUpdateWithRetryMutex.Lock()
	ret, specificReturn := fake.statusUpdateWithRetryReturnsOnCall[len(fake.statusUpdateWithRetryArgsForCall)]
	fake.statusUpdateWithRetryArgsForCall = append(fake.statusUpdateWithRetryArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.SubResourceUpdateOption
	}{arg1, arg2, arg3})
	stub := fake.StatusUpdateWithRetryStub
	fakeReturns := fake.statusUpdateWithRetryReturns
	fake.recordInvocation("StatusUpdateWithRetry", []interface{}{arg1, arg2, arg3})
	fake.statusUpdateWithRetryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetryCallCount() int {
	fake.statusUpdateWithRetryMutex.RLock()
	defer fake.statusUpdateWithRetryMutex.RUnlock()
	return len(fake.statusUpdateWithRetryArgsForCall)
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetryCalls(stub func(context.Context, clienta.Object, ...clienta.SubResourceUpdateOption) error) {
	fake.statusUpdateWithRetryMutex.Lock()
	defer fake.statusUpdateWithRetryMutex.Unlock()
	fake.StatusUpdateWithRetryStub = stub
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetryArgsForCall(i int) (context.Context, clienta.Object, []clienta.SubResourceUpdateOption) {
	fake.statusUpdateWithRetryMutex.RLock()
	defer fake.statusUpdateWithRetryMutex.RUnlock()
	argsForCall := fake.statusUpdateWithRetryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetryReturns(result1 error) {
	fake.statusUpdateWithRetryMutex.Lock()
	defer fake.statusUpdateWithRetryMutex.Unlock()
	fake.StatusUpdateWithRetryStub = nil
	fake.statusUpdateWithRetryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) StatusUpdateWithRetryReturnsOnCall(i int, result1 error) {
	fake.statusUpdateWithRetryMutex.Lock()
	defer fake.statusUpdateWithRetryMutex.Unlock()
	fake.StatusUpdateWithRetryStub = nil
	if fake.statusUpdateWithRetryReturnsOnCall == nil {
		fake.statusUpdateWithRetryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statusUpdateWithRetryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) Update(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.UpdateOption) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.UpdateOption
	}{arg1, arg2, arg3})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeCustomCtrlClient) UpdateCalls(stub func(context.Context, clienta.Object, ...clienta.UpdateOption) error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeCustomCtrlClient) UpdateArgsForCall(i int) (context.Context, clienta.Object, []clienta.UpdateOption) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) UpdateReturns(result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) UpdateReturnsOnCall(i int, result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) UpdateWithRetry(arg1 context.Context, arg2 clienta.Object, arg3 ...clienta.UpdateOption) error {
	fake.updateWithRetryMutex.Lock()
	ret, specificReturn := fake.updateWithRetryReturnsOnCall[len(fake.updateWithRetryArgsForCall)]
	fake.updateWithRetryArgsForCall = append(fake.updateWithRetryArgsForCall, struct {
		arg1 context.Context
		arg2 clienta.Object
		arg3 []clienta.UpdateOption
	}{arg1, arg2, arg3})
	stub := fake.UpdateWithRetryStub
	fakeReturns := fake.updateWithRetryReturns
	fake.recordInvocation("UpdateWithRetry", []interface{}{arg1, arg2, arg3})
	fake.updateWithRetryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomCtrlClient) UpdateWithRetryCallCount() int {
	fake.updateWithRetryMutex.RLock()
	defer fake.updateWithRetryMutex.RUnlock()
	return len(fake.updateWithRetryArgsForCall)
}

func (fake *FakeCustomCtrlClient) UpdateWithRetryCalls(stub func(context.Context, clienta.Object, ...clienta.UpdateOption) error) {
	fake.updateWithRetryMutex.Lock()
	defer fake.updateWithRetryMutex.Unlock()
	fake.UpdateWithRetryStub = stub
}

func (fake *FakeCustomCtrlClient) UpdateWithRetryArgsForCall(i int) (context.Context, clienta.Object, []clienta.UpdateOption) {
	fake.updateWithRetryMutex.RLock()
	defer fake.updateWithRetryMutex.RUnlock()
	argsForCall := fake.updateWithRetryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomCtrlClient) UpdateWithRetryReturns(result1 error) {
	fake.updateWithRetryMutex.Lock()
	defer fake.updateWithRetryMutex.Unlock()
	fake.UpdateWithRetryStub = nil
	fake.updateWithRetryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) UpdateWithRetryReturnsOnCall(i int, result1 error) {
	fake.updateWithRetryMutex.Lock()
	defer fake.updateWithRetryMutex.Unlock()
	fake.UpdateWithRetryStub = nil
	if fake.updateWithRetryReturnsOnCall == nil {
		fake.updateWithRetryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateWithRetryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomCtrlClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createOrUpdateObjectMutex.RLock()
	defer fake.createOrUpdateObjectMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	fake.statusUpdateWithRetryMutex.RLock()
	defer fake.statusUpdateWithRetryMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateWithRetryMutex.RLock()
	defer fake.updateWithRetryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCustomCtrlClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.CustomCtrlClient = new(FakeCustomCtrlClient)
